package internal

import (
	"bytes"
	"errors"
	"fmt"
	"go/doc/comment"
	"go/format"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"text/template"

	_ "embed"
)

//go:embed dbgen.tmpl
var dbgenTmpl []byte

type DBInfo struct {
	// Product name (e.g., IP2Location).
	Product string

	// Product code in the database header.
	ProductCode uint8

	// Database edition name prefix (e.g., DB).
	TypePrefix string

	// Maximum supported database edition (e.g., 11 for DB11).
	TypeMax uint8

	// Database fields.
	Field []DBField
}

type DBField struct {
	// Field name.
	GoName string

	// Documentation.
	GoDoc string

	// Field type.
	Type DBFieldType

	// Number of bytes to add to a resolved strptr.
	StrPtrRel int

	// [DBTypeMax]offset (zero for not present)
	Offset []uint8
}

func (f DBField) WrappedDocComment(tabs int, width int) string {
	if f.GoDoc != "" {
		var cr comment.Printer
		cr.TextPrefix = strings.Repeat("\t", tabs) + "// "
		cr.TextWidth = 80 - tabs*4 - 3 // godoc uses a tab width of 4
		return "\n" + strings.TrimRight(string(cr.Text(new(comment.Parser).Parse(f.GoDoc))), "\n")
	}
	return ""
}

type DBFieldType string

const (
	DBFieldTypeStrPtr        DBFieldType = "strptr"
	DBFieldTypeStrPtrFloat32 DBFieldType = "strptr.float32"
	DBFieldTypeFloat32       DBFieldType = "float32"
)

func (d DBFieldType) GoType() string {
	switch d {
	case DBFieldTypeStrPtr:
		return "string"
	case DBFieldTypeStrPtrFloat32, DBFieldTypeFloat32:
		return "float32"
	default:
		panic("unhandled db field type")
	}
}

// DBGenMain generates a parse for the IP2Location database described by info.
// It should be called by the main function in a ignored Go main file in the
// same folder as the target package.
func DBGenMain(info DBInfo) {
	pkg := strings.ToLower(info.Product)

	wd, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "dbgen: fatal: get cwd: %v\n", err)
		os.Exit(1)
	}

	_, fn, _, ok := runtime.Caller(1)
	if !ok {
		fmt.Fprintf(os.Stderr, "dbgen: fatal: failed to get caller filename\n")
		os.Exit(1)
	}

	if filepath.IsAbs(fn) {
		if fn, err = filepath.Rel(wd, fn); err != nil {
			fmt.Fprintf(os.Stderr, "dbgen: fatal: get relative filename: %v\n", err)
			os.Exit(1)
		}
	}

	var b bytes.Buffer
	b.WriteString("// Code generated by dbgen; DO NOT EDIT.\n\n")
	if err := template.Must(template.New("").Funcs(template.FuncMap{
		"error": func(s string) (string, error) {
			return "", errors.New(s)
		},
		"String": strconv.Quote,
		"ArrayValues": func(v []uint8) string {
			var b strings.Builder
			b.WriteByte('{')
			for i, x := range v {
				if i != 0 {
					b.WriteByte(',')
					b.WriteByte(' ')
				}
				b.WriteString(strconv.Itoa(int(x)))
			}
			b.WriteByte('}')
			return b.String()
		},
		"MainFile": func() string {
			return fn
		},
		"GoPackage": func() string {
			return pkg
		},
	}).Parse(string(dbgenTmpl))).Execute(&b, info); err != nil {
		fmt.Fprintf(os.Stderr, "dbgen: fatal: execute template: %v\n", err)
		os.Exit(1)
	}
	src := b.Bytes()

	if err := os.WriteFile(pkg+".go", src, 0666); err != nil {
		fmt.Fprintf(os.Stderr, "dbgen: fatal: write output: %v\n", err)
		os.Exit(1)
	}

	if src, err = format.Source(b.Bytes()); err != nil {
		fmt.Fprintf(os.Stderr, "dbgen: fatal: gofmt: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(pkg+".go", src, 0666); err != nil {
		fmt.Fprintf(os.Stderr, "dbgen: fatal: write output: %v\n", err)
		os.Exit(1)
	}
}

func (d *DBInfo) field(f DBField) {
	if f.Offset[0] != 0 {
		panic("first offset must be zero (it's just padding)")
	}
	if len(f.Offset) != int(d.TypeMax) {
		panic("wrong number of offsets for field")
	}
	d.Field = append(d.Field, f)
}

// StrPtr is a helper to add a string field.
func (d *DBInfo) StrPtr(GoName string, Offset ...uint8) {
	d.field(DBField{
		GoName:    GoName,
		Type:      DBFieldTypeStrPtr,
		StrPtrRel: 0,
		Offset:    append([]uint8{0}, Offset...),
	})
}

// StrPtrRel is a helper to add a string field.
func (d *DBInfo) StrPtrRel(StrPtrRel int, GoName string, Offset ...uint8) {
	d.field(DBField{
		GoName:    GoName,
		Type:      DBFieldTypeStrPtr,
		StrPtrRel: StrPtrRel,
		Offset:    append([]uint8{0}, Offset...),
	})
}

// StrPtrFloat32 is a helper to add a string float32 field.
func (d *DBInfo) StrPtrFloat32(GoName string, Offset ...uint8) {
	d.field(DBField{
		GoName:    GoName,
		Type:      DBFieldTypeStrPtrFloat32,
		StrPtrRel: 0,
		Offset:    append([]uint8{0}, Offset...),
	})
}

// Float32 is a helper to add a string float32 field.
func (d *DBInfo) Float32(GoName string, Offset ...uint8) {
	d.field(DBField{
		GoName: GoName,
		Type:   DBFieldTypeFloat32,
		Offset: append([]uint8{0}, Offset...),
	})
}

// Doc is a helper to add documentation to a field.
func (d *DBInfo) Doc(GoName string, GoDoc ...string) {
	for i, f := range d.Field {
		if f.GoName == GoName {
			(&d.Field[i]).GoDoc = strings.Join(GoDoc, "\n")
			return
		}
	}
	panic("no such field")
}
